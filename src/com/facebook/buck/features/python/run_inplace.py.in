#!<PYTHON> <PYTHON_INTERPRETER_FLAGS>

import os
import platform
import signal
import subprocess
import sys

main_module = <MAIN_MODULE>

def try_resolve_possible_symlink(path):
    import ctypes
    import ctypes.wintypes

    wintypes = ctypes.wintypes

    OPEN_EXISTING = 3
    FILE_FLAG_BACKUP_SEMANTICS = 0x02000000
    INVALID_HANDLE_VALUE = -1

    CreateFile = ctypes.windll.kernel32.CreateFileW
    CreateFile.argtypes = [wintypes.LPCWSTR, wintypes.DWORD, wintypes.DWORD,
                           wintypes.LPVOID, wintypes.DWORD, wintypes.DWORD,
                           wintypes.HANDLE]
    CreateFile.restype = wintypes.HANDLE

    CloseHandle = ctypes.windll.kernel32.CloseHandle
    CloseHandle.argtypes = [wintypes.HANDLE]
    CloseHandle.restype = wintypes.BOOL

    GetFinalPathNameByHandle = ctypes.windll.kernel32.GetFinalPathNameByHandleW
    GetFinalPathNameByHandle.argtypes = [wintypes.HANDLE, wintypes.LPWSTR, wintypes.DWORD, wintypes.DWORD]
    GetFinalPathNameByHandle.restype = wintypes.DWORD

    handle = INVALID_HANDLE_VALUE
    try:
        handle = CreateFile(path, 0, 0, None, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, None)
        if handle == INVALID_HANDLE_VALUE:
            return path

        path_buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH + 1)
        if GetFinalPathNameByHandle(handle, path_buf, wintypes.MAX_PATH + 1, 0) == 0:
            return path

        # avoid literal backslash (ASCII octal 134) to get out of multilevel quoting hell
        if path_buf.value.startswith(chr(0o134) + chr(0o134) + '?' + chr(0o134)):
            return path_buf.value[4:]

        return path_buf.value
    finally:
        if handle != INVALID_HANDLE_VALUE:
            CloseHandle(handle)

dirpath = os.path.dirname(os.path.realpath(__file__))
if platform.system() == "Windows":
    # Hah hah just kidding. __file__ will point to the symlink and not the
    # actual pex we want to execute, if we're in a symlink. os.path.realpath
    # does *not* dereference symlinks on windows until, like, 3.8 maybe.
    dirpath = os.path.dirname(try_resolve_possible_symlink(sys.argv[0]))

interpreter_wrapper_path = os.path.join(dirpath, <INTERPRETER_WRAPPER_REL_PATH>)
interpreter_flags = ["<PYTHON_INTERPRETER_FLAGS>"]

# Default to 'd' warnings, but allow users to control this via PYTHONWARNINGS
# The -E causes python to ignore all PYTHON* environment vars so we have to
# pass this down using the command line.
warnings = os.environ.get("PYTHONWARNINGS", "d").split(",")
for item in reversed(warnings):
    interpreter_flags.insert(0, "-W{0}".format(item.strip()))

# Allow users to disable byte code generation by setting the standard environment var.
# Same as above, because of -E we have to pass this down using the command line.
if "PYTHONDONTWRITEBYTECODE" in os.environ:
    interpreter_flags.insert(0, "-B")

# Python 3.7 allows benchmarking import time with this variable. Similar issues to
# PYTHONDONTWRITEBYTECODE above. If using an earlier version of python... dont set this
# Make sure we only run this on cpython where it's supported (python2 will fail
# if given an unknown -X)
if (
    "PYTHONPROFILEIMPORTTIME" in os.environ
    and platform.python_implementation() == "CPython"
    and (sys.version_info[0], sys.version_info[1]) >= (3, 7)
):
    interpreter_flags[0:0] = ["-X", "importtime"]

if platform.system() == "Windows":
    # Native dependencies are not supported on Windows so we don't have to
    # "exec" the interpreter wrapper (which itself "exec" the Python
    # interpreter). To avoid unneccesary "exec"-s on Windows (which has to be
    # simulated with `CreateProcess`), we use the interpreter wrapper as a
    # library to prepare the startup command and directly "exec" the Python
    # interpreter.
    if sys.version_info >= (3, 0):
        import importlib.machinery
        loader = importlib.machinery.SourceFileLoader("interpreter_wrapper", interpreter_wrapper_path)
        interpreter_wrapper = loader.load_module()
    else:
        # Buck is sunsetting Python2 support. However this is still need for
        # some unit tests.
        import imp
        interpreter_wrapper = imp.load_source("interpreter_wrapper", interpreter_wrapper_path)
    startup_command = interpreter_wrapper.prepare_startup_command(
        main_module=main_module, arg0=sys.argv[0], dirpath=dirpath
    )
    args = interpreter_flags + ["-c", startup_command] + sys.argv[1:]

    # exec on Windows is not true exec - there is only 'spawn' ('CreateProcess').
    # However, creating processes unnecessarily is painful, so we only do the spawn
    # path if we have to, which is on Windows. That said, this complicates signal
    # handling, so we need to set up some signal forwarding logic.

    p = subprocess.Popen([sys.executable] + args)

    def handler(signum, frame):
        # If we're getting this, we need to forward signum to subprocesses
        if signum == signal.SIGINT:
            p.send_signal(signal.CTRL_C_EVENT)
        elif signum == signal.SIGBREAK:
            p.send_signal(signal.CTRL_BREAK_EVENT)
        else:
            # shouldn't happen, we should be killed instead
            p.terminate()

    signal.signal(signal.SIGINT, handler)
    signal.signal(signal.SIGBREAK, handler)

    p.wait()
    sys.exit(p.returncode)
else:
    # When arg0 is the par file, we tell the interpreter wrapper to preserve it.
    if sys.argv[0] == __file__:
        os.environ["__ARG0_OVERRIDE"] = __file__

    args = [interpreter_wrapper_path] + interpreter_flags + ["-m", main_module] + sys.argv[1:]
    os.execv(interpreter_wrapper_path, args)
